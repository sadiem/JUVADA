//################################################
//<Matrix.cpp>
// 変換マトリックス作成
//------------------------------------------------
//座標変換
//2012/06/15 ~
//						SekiyamaRumi
//################################################
#include "Matrix.h"		//

//====================================================
// プロトタイプ宣言
//====================================================

//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■初期化
//／　＊
//　　＊	１　０　０　０
//　　＊	０　１　０　０
//　　＊	０　０　１　０
//　　＊	０　０　０　１
//　　＊
//--In------------------------------------------------
// 元となる行列
//--Out-----------------------------------------------
// なし
//++++++++++++++++++++++++++++++++++++++++++++++++++++
void MatrixIdentity(MATRIX *m)														//初期化
{
	for(int nLoop1 = 0; nLoop1 < 4; nLoop1 ++)
	{
		for(int nLoop2 = 0; nLoop2 < 4; nLoop2 ++)
		{
			if(nLoop1 == nLoop2)
				m->m[nLoop1][nLoop2] = 1;
			else
				m->m[nLoop1][nLoop2] = 0;
		}
	}
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■平行移動の処理
//／　＊
//　　＊
//--In------------------------------------------------
// 元となるマトリックス
// Ｘ方向の移動量
// Ｙ方向の移動量
// Ｚ方向の移動量
//--Out-----------------------------------------------
// なし
//++++++++++++++++++++++++++++++++++++++++++++++++++++
void MatrixTranslation(MATRIX *m, float fX, float fY, float fZ)						//平行移動
{
	MatrixIdentity(m);	//マトリックスを一度初期化
	m->m[3][0] = fX;
	m->m[3][1] = fY;
	m->m[3][2] = fZ;

}
//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■拡大縮小の処理
//／　＊
//　　＊
//--In------------------------------------------------
// 元となるマトリックス
// Ｘ方向の拡大率
// Ｙ方向の拡大率
// Ｚ方向の拡大率
//--Out-----------------------------------------------
// なし
//++++++++++++++++++++++++++++++++++++++++++++++++++++
void MatrixScaling(MATRIX *m, float fSx, float fSy, float fSz)						//拡大縮小
{
	MatrixIdentity(m);	//マトリックスを一度初期化
	m->m[0][0] = fSx;
	m->m[1][1] = fSy;
	m->m[2][2] = fSz;
	
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■Ｘ軸回転処理
//／　＊
//　　＊
//--In------------------------------------------------
// 元となるマトリックス
// 回転角
//--Out-----------------------------------------------
// なし
//++++++++++++++++++++++++++++++++++++++++++++++++++++
void MatrixRotationX(MATRIX *m, float fPitch)										//X軸回転
{
	float s = sinf(fPitch);
	float c = cosf(fPitch);
	
	MatrixIdentity(m);	//マトリックスを一度初期化
	m->m[1][1] = c;
	m->m[2][1] = -s;
	m->m[1][2] = s;
	m->m[2][2] = c;
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■Ｙ軸回転処理
//／　＊Ｙ軸を中心にして回転させる
//　　＊
//--In------------------------------------------------
// 元となるマトリックス
// 回転角
//--Out-----------------------------------------------
// なし
//++++++++++++++++++++++++++++++++++++++++++++++++++++
void MatrixRotationY(MATRIX *m, float fYaw)											//Y軸回転
{
	MatrixIdentity(m);	//マトリックスを一度初期化
	m->m[0][0] = m->m[2][2] = cosf(fYaw);
	m->m[2][0] = sinf(fYaw);
	m->m[0][2] = -sinf(fYaw);
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■Ｚ軸回転処理
//／　＊Ｚ軸を中心にして回転させる
//　　＊
//--In------------------------------------------------
// 
//--Out-----------------------------------------------
// 
//++++++++++++++++++++++++++++++++++++++++++++++++++++
void MatrixRotationZ(MATRIX *m, float fRoll)											//Z軸回転
{
	MatrixIdentity(m);	//マトリックスを一度初期化
	m->m[0][1] = m->m[1][1] = cosf(fRoll);
	m->m[1][0] = -sinf(fRoll);
	m->m[0][1] = sinf(fRoll);

}
//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■行列の合成処理
//／　＊受け取った行列に回転をかける
//　　＊Ｘ・Ｙ・Ｚ回転の順であること
//--In------------------------------------------------
// 変更元の行列
// Ｘ軸への回転角
// Ｙ軸への回転角
// Ｚ軸への回転角
//--Out-----------------------------------------------
// なし
//++++++++++++++++++++++++++++++++++++++++++++++++++++
void MatrixRotationYawPitchRoll(MATRIX *m, float fYaw, float fPitch, float fRoll)		//
{
	MATRIX mX, mY, mZ;
	MatrixIdentity(&mX);
	MatrixIdentity(&mY);
	MatrixIdentity(&mZ);

	MatrixRotationX(&mX, fPitch);
	MatrixRotationY(&mY, fYaw);
	MatrixRotationZ(&mZ, fRoll);
	MatrixMultiply(m, mZ, mX);
	MatrixMultiply(m, *m, mY);

}
//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■任意軸回転の処理
//／　＊回転軸を受け取り、回転軸を基に回転させる
//　　＊
//--In------------------------------------------------
// 変更元の行列
// 回転軸のベクトル
// 角度
//--Out-----------------------------------------------
// なし
//++++++++++++++++++++++++++++++++++++++++++++++++++++
void MatrixRotationAxis(MATRIX *m, VECTOR3 v, float fAngle)							
{
	float s = sinf(fAngle);
	float c = cosf(fAngle);
	float d = 1.0f - c;
	float &x = v.v[0];
	float &y = v.v[1];
	float &z = v.v[2];
	m->m[0][0] = c + d * x * x;
	m->m[0][1] = d * x * y + s * z;
	m->m[0][2] = d * x * z - s * y;
	m->m[0][3] = 0.0f;

	m->m[1][0] = d * x * y - s * z;
	m->m[1][1] = c + d * y * y;
	m->m[1][2] = d * y * z + s * x;
	m->m[1][3] = 0.0f;

	m->m[2][0] = d * x * z + s * y;
	m->m[2][1] = d * y * z - s * x;
	m->m[2][2] = c + d * z * z;
	m->m[2][3] = 0.0f;

	m->m[3][0] = 0.0f;
	m->m[3][1] = 0.0f;
	m->m[3][2] = 0.0f;
	m->m[3][3] = 1.0f;

}
//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■行列の掛け算処理
//／　＊答えが入る行列 = 左辺行列　＊　右辺行列
//　　＊
//--In------------------------------------------------
// 答えが入る行列
// 左辺
// 右辺
//--Out-----------------------------------------------
// 
//++++++++++++++++++++++++++++++++++++++++++++++++++++
void MatrixMultiply(MATRIX *m, MATRIX mL, MATRIX mR)									//掛け算
{
	
	if(m->m == mL.m || m->m == mR.m)
	{	//代入先の変数と同じものを計算に使用

		MATRIX mat;

		for(int nLoop1 = 0; nLoop1 < 4; nLoop1++)
		{
			for(int nLoop2 = 0; nLoop2 < 4; nLoop2++)
			{
				mat.m[nLoop1][nLoop2] = 0.0f;
				for(int nLoop3 = 0; nLoop3 < 4; nLoop3++)
				{
					mat.m[nLoop1][nLoop2] += mL.m[nLoop3][nLoop2] * mR.m[nLoop1][nLoop3];	//掛け算
				}
			}
		}

		*m = mat;
	}
	else
	{	//計算値と結果が異なる変数
		for(int nLoop1 = 0; nLoop1 < 4; nLoop1++)
		{
			for(int nLoop2 = 0; nLoop2 < 4; nLoop2++)
			{
				m->m[nLoop1][nLoop2] = 0.0f;
				for(int nLoop3 = 0; nLoop3 < 4; nLoop3++)
				{
					m->m[nLoop1][nLoop2] += mL.m[nLoop3][nLoop2] * mR.m[nLoop1][nLoop3];	//掛け算
				}
			}
		}
	}
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■逆行列
//／　＊
//　　＊
//--In------------------------------------------------
// 変換後マトリックス
// 変換マトリックス
//--Out-----------------------------------------------
// 
//++++++++++++++++++++++++++++++++++++++++++++++++++++
void MatrixInv(MATRIX *mat, MATRIX m)
{
	MATRIX tmp;
	float  det;


	det = m._11 * m._22 * m._33 * m._44 + m._11 * m._23 * m._34 * m._42 + m._11 * m._24 * m._32 * m._43
		
		+ m._12 * m._21 * m._34 * m._43	+ m._12 * m._23 * m._31 * m._44	+ m._12 * m._24 * m._33 * m._41

		+ m._13 * m._21 * m._32 * m._44	+ m._13 * m._22 * m._34 * m._41	+ m._13 * m._24 * m._31 * m._42

		+ m._14 * m._21 * m._33 * m._42	+ m._14 * m._22 * m._31 * m._43	+ m._14 * m._23 * m._32 * m._41

		- m._11 * m._22 * m._34 * m._43	- m._11 * m._23 * m._32 * m._44	- m._11 * m._24 * m._33 * m._42

		- m._12 * m._21 * m._33 * m._44	- m._12 * m._23 * m._34 * m._41	- m._12 * m._24 * m._31 * m._43

		- m._13 * m._21 * m._34 * m._42	- m._13 * m._22 * m._31 * m._44	- m._13 * m._24 * m._32 * m._41

		- m._14 * m._21 * m._32 * m._43	- m._14 * m._22 * m._33 * m._41	- m._14 * m._23 * m._31 * m._42;


	
	//逆行列が存在してたら
	if(det != 0)
	{
		tmp._11 = (1 / det) *
				( m._22 * m._33 * m._44 
				+ m._23 * m._34 * m._42
				+ m._24 * m._32 * m._43
				- m._22 * m._34 * m._43
				- m._23 * m._32 * m._44
				- m._24 * m._33 * m._42);

		tmp._12 = (1 / det) *
				 (m._12 * m._34 * m._43 
				+ m._13 * m._32 * m._44
				+ m._14 * m._33 * m._42
				- m._12 * m._33 * m._44
				- m._13 * m._34 * m._42
				- m._14 * m._32 * m._43);

		tmp._13 = (1 / det) *
				 (m._12 * m._23 * m._44 
				+ m._13 * m._24 * m._42
				+ m._14 * m._22 * m._43
				- m._12 * m._24 * m._43
				- m._13 * m._22 * m._44
				- m._14 * m._23 * m._42);

		tmp._14 = (1 / det) *
				(m._12 * m._24 * m._33 
				+ m._13 * m._22 * m._34
				+ m._14 * m._23 * m._32
				- m._12 * m._23 * m._34
				- m._13 * m._24 * m._32
				- m._14 * m._22 * m._33);

		tmp._21 = (1 / det) *
				(m._21 * m._34 * m._43 
				+ m._23 * m._31 * m._44
				+ m._24 * m._33 * m._41
				- m._21 * m._33 * m._44
				- m._23 * m._34 * m._41
				- m._24 * m._31 * m._43);

		tmp._22 = (1 / det) *
				(m._11 * m._33 * m._44 
				+ m._13 * m._34 * m._41
				+ m._14 * m._31 * m._43
				- m._11 * m._34 * m._43
				- m._13 * m._31 * m._44
				- m._14 * m._33 * m._41);

		tmp._23 = (1 / det) *
				(m._11 * m._24 * m._43 
				+ m._13 * m._21 * m._44
				+ m._14 * m._23 * m._41
				- m._11 * m._23 * m._44
				- m._13 * m._24 * m._41
				- m._14 * m._21 * m._43);

		tmp._24 = (1 / det) *
				(m._11 * m._23 * m._34 
				+ m._13 * m._24 * m._31
				+ m._14 * m._21 * m._33
				- m._11 * m._24 * m._33
				- m._13 * m._21 * m._34
				- m._14 * m._23 * m._31);

		tmp._31 = (1 / det) *
				(m._21 * m._32 * m._44 
				+ m._22 * m._34 * m._41
				+ m._24 * m._31 * m._42
				- m._21 * m._34 * m._42
				- m._22 * m._31 * m._44
				- m._24 * m._32 * m._41);

		tmp._32 = (1 / det) *
				(m._11 * m._34 * m._42 
				+ m._12 * m._31 * m._44
				+ m._14 * m._32 * m._41
				- m._11 * m._32 * m._44
				- m._12 * m._34 * m._41
				- m._14 * m._31 * m._42);

		tmp._33 = (1 / det) *
				(m._11 * m._22 * m._44 
				+ m._12 * m._24 * m._41
				+ m._14 * m._21 * m._42
				- m._11 * m._24 * m._42
				- m._12 * m._21 * m._44
				- m._14 * m._22 * m._41);

		tmp._34 = (1 / det) *
				(m._11 * m._24 * m._32 
				+ m._12 * m._21 * m._34
				+ m._14 * m._22 * m._31
				- m._11 * m._22 * m._34
				- m._12 * m._24 * m._31
				- m._14 * m._21 * m._32);

		tmp._41 = (1 / det) *
				(m._21 * m._33 * m._42 
				+ m._22 * m._31 * m._43
				+ m._23 * m._32 * m._41
				- m._21 * m._32 * m._43
				- m._22 * m._33 * m._41
				- m._23 * m._31 * m._42);

		tmp._42 = (1 / det) *
				(m._11 * m._32 * m._43 
				+ m._12 * m._33 * m._41
				+ m._13 * m._31 * m._42
				- m._11 * m._33 * m._42
				- m._12 * m._31 * m._43
				- m._13 * m._32 * m._41);

		tmp._43 = (1 / det) *
				(m._11 * m._23 * m._42 
				+ m._12 * m._21 * m._43
				+ m._13 * m._22 * m._41
				- m._11 * m._22 * m._43
				- m._12 * m._23 * m._41
				- m._13 * m._21 * m._42);

		tmp._44 = (1 / det) *
				(m._11 * m._22 * m._33 
				+ m._12 * m._23 * m._31
				+ m._13 * m._21 * m._32
				- m._11 * m._23 * m._32
				- m._12 * m._21 * m._33
				- m._13 * m._22 * m._31);

		//登録
		mat->_11 = tmp._11;
		mat->_12 = tmp._12;
		mat->_13 = tmp._13;
		mat->_14 = tmp._14;

		mat->_21 = tmp._21;
		mat->_22 = tmp._22;
		mat->_23 = tmp._23;
		mat->_24 = tmp._24;

		mat->_31 = tmp._31;
		mat->_32 = tmp._32;
		mat->_33 = tmp._33;
		mat->_34 = tmp._34;

		mat->_41 = tmp._41;
		mat->_42 = tmp._42;
		mat->_43 = tmp._43;
		mat->_44 = tmp._44;

	}
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■転置行列
//／　＊
//　　＊
//--In------------------------------------------------
// 変換後マトリックス
// 変換マトリックス
//--Out-----------------------------------------------
// なし
//++++++++++++++++++++++++++++++++++++++++++++++++++++
void MatrixTransposition(MATRIX *mat, MATRIX &m)
{
	//転置行列を求める
	mat->m[0][0] = m.m[0][0];
	mat->m[0][1] = m.m[1][0];
	mat->m[0][2] = m.m[2][0];
	mat->m[0][3] = m.m[3][0];

	mat->m[1][0] = m.m[0][1];
	mat->m[1][1] = m.m[1][1];
	mat->m[1][2] = m.m[2][1];
	mat->m[1][3] = m.m[3][1];

	mat->m[2][0] = m.m[0][2];
	mat->m[2][1] = m.m[1][2];
	mat->m[2][2] = m.m[2][2];
	mat->m[2][3] = m.m[3][2];

	mat->m[3][0] = m.m[0][3];
	mat->m[3][1] = m.m[1][3];
	mat->m[3][2] = m.m[2][3];
	mat->m[3][3] = m.m[3][3];


}
//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■ベクトル初期化
//／　＊初期化
//　　＊
//--In------------------------------------------------
// 初期化するベクトル
//--Out-----------------------------------------------
// 
//++++++++++++++++++++++++++++++++++++++++++++++++++++
void Vec3Identity(VECTOR3 *vec)
{
	vec->x = 0.0f;
	vec->y = 0.0f;
	vec->z = 0.0f;
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■移動成分含みの回転処理
//／　＊座標上の移動も含まれる
//　　＊Ｗ成分含む
//--In------------------------------------------------
// 代入先のベクトル
// 元となるマトリックス
// ベクトル
//--Out-----------------------------------------------
// 
//++++++++++++++++++++++++++++++++++++++++++++++++++++
void Vec3TransformCoord(VECTOR3 *v, MATRIX m, VECTOR3 vS)							//
{
	int nLoop1, nLoop2;
	if(v->v == vS.v)
	{
		VECTOR3 vecTmp;

		//代入先のベクトルと同じものを計算に使用
		for(nLoop1 = 0; nLoop1 < 3; nLoop1 ++)
		{
			vecTmp.v[nLoop1] = 0.0f;
			for(nLoop2 = 0; nLoop2 < 3; nLoop2 ++)
			{
				vecTmp.v[nLoop1] += m.m[nLoop2][nLoop1] * vS.v[nLoop2];
			}
			vecTmp.v[nLoop1] += m.m[nLoop2][nLoop1] * 1.0f;
		}
		*v = vecTmp;
	}
	else
	{
		for( nLoop1 = 0; nLoop1 < 3; nLoop1 ++)
		{
			v->v[nLoop1] = 0.0f;
			for( nLoop2 = 0; nLoop2 < 3; nLoop2 ++)
			{
				v->v[nLoop1] += m.m[nLoop2][nLoop1] * vS.v[nLoop2];
			}
			v->v[nLoop1] += m.m[nLoop2][nLoop1] * 1.0f;
		}
	}
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■回転成分のみの回転処理
//／　＊法線ベクトル用
//　　＊Ｗ成分含まないll
//--In------------------------------------------------
// 
//--Out-----------------------------------------------
// 
//++++++++++++++++++++++++++++++++++++++++++++++++++++
void Vec3TransformNormal(VECTOR3 *v, MATRIX m, VECTOR3 vR)							//
{

	if(v->v == vR.v)
	{
		VECTOR3 vecTmp;

		//代入先のベクトルと同じものを使用
		for(int nLoop1 = 0; nLoop1 < 3; nLoop1 ++)
		{
			vecTmp.v[nLoop1] = 0.0f;
			for(int nLoop2 = 0; nLoop2 < 3; nLoop2 ++)
			{
				vecTmp.v[nLoop1] += m.m[nLoop2][nLoop1] * vR.v[nLoop2];
			}
		}
		*v = vecTmp;
	}
	else
	{
		for(int nLoop1 = 0; nLoop1 < 3; nLoop1 ++)
		{
			v->v[nLoop1] = 0.0f;
			for(int nLoop2 = 0; nLoop2 < 3; nLoop2 ++)
			{
				v->v[nLoop1] += m.m[nLoop2][nLoop1] * vR.v[nLoop2];
			}
		}
	}

}
//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■外積
//／　＊
//　　＊
//--In------------------------------------------------
// 
//--Out-----------------------------------------------
// 
//++++++++++++++++++++++++++++++++++++++++++++++++++++
void Vec3Cross(VECTOR3 *v, VECTOR3 vL, VECTOR3 vR)									//
{
	if(v->v == vL.v || v->v == vR.v)
	{
		VECTOR3 vecTmp;

		vecTmp.v[0] = vL.v[1] * vR.v[2] - vL.v[2] * vR.v[1];
		vecTmp.v[1] = vL.v[2] * vR.v[0] - vL.v[0] * vR.v[2];
		vecTmp.v[2] = vL.v[0] * vR.v[1] - vL.v[1] * vR.v[0];

		*v = vecTmp;

	}else
	{
		v->v[0] = vL.v[1] * vR.v[2] - vL.v[2] * vR.v[1];
		v->v[1] = vL.v[2] * vR.v[0] - vL.v[0] * vR.v[2];
		v->v[2] = vL.v[0] * vR.v[1] - vL.v[1] * vR.v[0];
	}
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■内積
//／　＊１と２のベクトルの内積を求める計算
//　　＊
//--In------------------------------------------------
// ベクトル１
// ベクトル２
//--Out-----------------------------------------------
// 内積の値
//++++++++++++++++++++++++++++++++++++++++++++++++++++
float Vec3Dot(VECTOR3 vL, VECTOR3 vR)												//
{
	float nTmp;

	nTmp = vL.v[0] * vR.v[0] + vL.v[1] * vR.v[1] + vL.v[2] * vR.v[2];
	return nTmp;
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■単位ベクトル
//／　＊
//　　＊
//--In------------------------------------------------
// ベクトルの単位行列
// 求めるベクトル
//--Out-----------------------------------------------
// 
//++++++++++++++++++++++++++++++++++++++++++++++++++++
void Vec3Normalize(VECTOR3 *v, VECTOR3& vR)											//
{
	float fTmp;
		
	fTmp = 1.0f / sqrtf(vR.v[0] * vR.v[0] + vR.v[1] * vR.v[1] + vR.v[2] * vR.v[2]);
	v->v[0] = vR.v[0] * fTmp;
	v->v[1] = vR.v[1] * fTmp;
	v->v[2] = vR.v[2] * fTmp;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■二つのベクトルの差
//／　＊
//　　＊
//--In------------------------------------------------
// ベクトルの大きさ
// 求めるベクトル1
// 求めるベクトル2
//--Out-----------------------------------------------
// 
//++++++++++++++++++++++++++++++++++++++++++++++++++++
float Vec3Length(VECTOR3 vR, VECTOR3 vL)
{
	float tmpX, tmpY, tmpZ;	//作業用
	float fLength = 0.0f;	//長さ

	tmpX = vR.v[0] - vL.v[0];
	tmpY = vR.v[1] - vL.v[1];
	tmpZ = vR.v[2] - vL.v[2];
	
	//長さ
	fLength = sqrt((float)tmpX * tmpX + tmpY * tmpY + tmpZ * tmpZ);

	if(tmpX == 0.0f && tmpY == 0.0f && tmpZ == 0.0f)
		fLength = 0;
	
	return fLength;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■ベクトル１と２から回転角を返す
//／　＊
//　　＊
//--In------------------------------------------------
// ベクトル１
// ベクトル２
//--Out-----------------------------------------------
// 回転角
//++++++++++++++++++++++++++++++++++++++++++++++++++++
float VectoVec(VECTOR3 vec1, VECTOR3 vec2)
{
	//変数定義
	VECTOR3 cross, dot;
	float   rad = 0.0f;

	//２つのベクトルの角度を出す
	rad = Vec3Dot(vec1, vec2);
	rad = rad / (VecLength(vec1) * VecLength(vec2));
	if(rad < -1)
		rad = -1;
	if(rad > 1)
		rad = 1;
	rad = (float)acos(rad);					//コサインをラジアンに。

	//外積から右向き左向きか判定
	Vec3Cross(&cross, vec1, vec2);
	if(cross.y >= 0)
		return rad;
	else if(cross.y < 0)
		return -rad;
	return 0;
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■ベクトルの大きさを調べる
//／
//--In------------------------------------------------
// ベクトル
//--Out-----------------------------------------------
// なし
//++++++++++++++++++++++++++++++++++++++++++++++++++++
float VecLength(VECTOR3 vec)
{
	return sqrtf(vec.x * vec.x + vec.y + vec.y + vec.z * vec.z);
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■ベクトルをスカラ倍する
//／　＊3次元ベクトルをスカラ倍する
//　　＊
//--In------------------------------------------------
// ベクトル１
// スカラ
//--Out-----------------------------------------------
// なし
//++++++++++++++++++++++++++++++++++++++++++++++++++++
void VecScale(VECTOR3 *vec, float fScale)
{
	vec->v[0] = vec->x * fScale;
	vec->v[1] = vec->y * fScale;
	vec->v[2] = vec->z * fScale;
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■ベクトルをスカラ倍マイナスする
//／　＊
//　　＊
//--In------------------------------------------------
// ベクトル１
// スカラ
//--Out-----------------------------------------------
// なし
//++++++++++++++++++++++++++++++++++++++++++++++++++++
void VecScaleM(VECTOR3 *vec, float fScale)
{
	VecScale(vec, (1.0f / fScale));
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++
//　■回転
//／　＊
//　　＊X/Z平面限定
//--In------------------------------------------------
// 受け取りベクトル
// スカラ
//--Out-----------------------------------------------
// なし
//++++++++++++++++++++++++++++++++++++++++++++++++++++
void VecRot(VECTOR3 *vec, float fRadius)
{
	vec->x = (float)cos((double)fRadius);
	vec->y = 0.0f;
	vec->z = (float)sin((double)fRadius);

}

void multiplication(GLfloat* src1,GLfloat* src2,GLfloat* dst)
{
 for(int y=0;y<4;y++){
  for(int x=0;x<4;x++){
   dst[y*4+x]=src2[y*4]*src1[x]+src2[y*4+1]*src1[x+4]+src2[y*4+2]*src1[x+8]+src2[y*4+3]*src1[x+12];
  }
 }
}